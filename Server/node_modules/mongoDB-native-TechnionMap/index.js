var mongoDB = require("mongodb"),
	spawn = require('child_process').spawn,
	path = require('path'),
	os = require('os'),
	fs = require('fs');

/*INTERNAL FUNCTIONS*/
function pr(txt){
	console.log(txt)
};

function formatDate() {
  var now = new Date();
  var d = new Date(now.getTime()+msecToUTC);
  var dd = d.getUTCDate();
  if ( dd < 10 ) dd = '0' + dd;
  var mm = d.getUTCMonth()+1;
  if ( mm < 10 ) mm = '0' + mm;
  var yy = d.getUTCFullYear() % 100;
  if ( yy < 10 ) yy = '0' + yy;
  var hh = d.getUTCHours();
  if ( hh < 10 ) hh = '0' + hh;
  var nn = d.getUTCMinutes();
  if ( nn < 10 ) nn = '0' + nn;
  var ss = d.getUTCSeconds();
  if ( ss < 10 ) ss = '0' + ss;
  return dd+'.'+mm+'.'+yy+'-'+hh+':'+nn+':'+ss
}
 function failJSON(msg,data){
		var msg=arguments[0];
	var dataArr=[];
	for (i = 1; i < arguments.length; i++){
		dataArr.push(arguments[i]);
	}
	return {status: "Failed", msg: msg,data:dataArr}
 }
 function okJSON(msg,data){
	var msg=arguments[0];
	var dataArr=[];
	if (!(data instanceof Array)){
		for (i = 1; i < arguments.length; i++){
			dataArr.push(arguments[i]);
		}
		return {status: "OK", msg: msg,data:dataArr}
	}else return {status: "OK", msg: msg,data:data}
 }
//spawn child process to execute mongoDb daemon (child shares stdout and stderr)
function spawnMongo(port,errorHandler,callback){
	var mongoDaemonPath ; 
	var mongoDBPath = path.join(__dirname, '..', '..','db');  //relative path to db. assumed path: ..\..\db
	
	osType = os.type(); // windows 8 - "Windows_NT"
	if (exports.debugMode) pr("OS type is " + osType); 
	if (osType === "Windows_NT") {
		mongoDaemonPath= '\\mongodb\\bin\\mongod.exe'; //assumed path: root\mongodb\bin\mongod.exe
	}else {
		mongoDaemonPath= '/usr/bin/mongod';
	}	
	if (spawnDaemonFlag) {
		pr('Node.js: '+formatDate()+": Spawning MongoDB daemon on port: "+port);
		daemonChild = spawn(mongoDaemonPath, ['-dbpath',mongoDBPath,'-port',port,'-quiet','-nohttpinterface']);
		if (exports.debugMode) pr("Daemon pid is: "+daemonChild.pid); 
		daemonChild.stdout.on('data', function (data) {
		  pr('MonogoDaemon: ' + data);
		});
		daemonChild.stderr.on('data', function (data) { //not working in ubuntu or just SSH?
		  pr('MonogoDaemon: STDERR:**************** ' + data);
		});
		daemonChild.on('exit', function (code,signal) { 
			if (code){ 
				if (code == 45) {
					pr('MonogoDaemon: '+formatDate()+': ****** Exited with code 45 - lock file of system file issue. ******');
					errorHandler(failJSON("dameonNeedsRepair"));
				}else {
					pr('MonogoDaemon: '+formatDate()+': ****** Exited with code ' + code+ '******');
					errorHandler(failJSON("dameonClosed"));
				}
			}else { 
			  pr('MonogoDaemon: '+formatDate()+': ****** Killed by signal ' + signal+ '******');
			  errorHandler(failJSON("dameonClosed"));
			}
		});
		/*
		daemonChild.on('SIGINT', function (code,signal) { //should work on ubuntu...
			 pr('MonogoDaemon: '+formatDate()+': ****** Exited with SIGINT ******');
			 errorHandler(failJSON("dameonClosed"));
		});
		*/
	};
	setTimeout(function(){callback(daemonChild)},1000);
};

function getFriendsData(user,cb){
	var now = new Date();
	var oldestUsersMoodTime=now.getTime()-usersMoodTimeFrame;
	var oldestProMUsersMoodTime=now.getTime()-promUsersMoodTimeFrame;
	
	usersCol.find({$and :[ {_id: {$in:user.usersIDarray}},//2
						   {lastUpdateTime:{$gte : oldestUsersMoodTime}}
						 ]}, 
				  {usersIDarray:0, _id:0}).sort({lastUpdateTime: -1}).toArray(
			function (err, dataArray){
				if (err) cb(failJSON("couldntSearch",user.userId,"GetFriends",err),null); //probably no connection
				else {
					var cursor = promUsersCol.find({lastUpdateTime:{$gte : oldestProMUsersMoodTime}});
					cursor.each(function(err, promUser) {
						if (err) {cb(failJSON("couldntSearch",user.userId,"GetFriends",err),null); //probably no connection
						}else {
							if (promUser != null) { //true when cursor exhausted
								dataArray.push(promUser);
							}else {
								cb(null, okJSON("Friends sent",dataArray));//4
							}
						}
					});
				}
			});
};

/*VARIABLES*/

var spawnDaemonFlag = true;
var daemonChild = null;

var db;
var host;
var port;
var usersCol;
var promUsersCol;
var msecToUTC = 3*3600000; // hours X msecs offset from local time to UTC
var usersMoodTimeFrame = 6*3600000; // max time in hours X msec per hour
var promUsersMoodTimeFrame = 12*3600000; //// max time in hours

/*EXPOSED*/
module.exports = exports = {
	debugMode : false,
	//gracefully stop daemon
	killDaemon: function(callback){
		db.close(function(err,result){
				if (err) pr('Node.js: '+formatDate()+": Can't close DB connection.");
				if (daemonChild) {
					pr('Node.js: '+formatDate()+": Killing MongoDB daemon listening on port: "+port);
					daemonChild.kill('SIGINT'); //self kill
				}
				callback();
		});
	},
	mongoRepair: function(){
			var mongoDaemonPath ; 
			var mongoDBPath = path.join(__dirname, '..', '..','db');  //relative path to db. assumed path: ..\..\db
			var mongoDBPathLockFile = path.join(__dirname, '..', '..','db','mongod.lock');
			var mongoDBPathJournalDir = path.join(__dirname, '..', '..','db','journal');
			var deleteFolderRecursive = function(path) {
				if( fs.existsSync(path) ) {
					fs.readdirSync(path).forEach(function(file,index){
					  var curPath = path + "/" + file;
					  if(fs.lstatSync(curPath).isDirectory()) { // recurse
						deleteFolderRecursive(curPath);
					  } else { // delete file
						fs.unlinkSync(curPath);
					  }
					});
					fs.rmdirSync(path);
				}
			};
			
			osType = os.type(); // windows 8 - "Windows_NT"
			if (exports.debugMode) pr("OS type is " + osType); 
			if (osType === "Windows_NT") {
				mongoDaemonPath= '\\mongodb\\bin\\mongod.exe'; //assumed path: root\mongodb\bin\mongod.exe
			}else {
				mongoDaemonPath= '/usr/bin/mongod';
			}
			try {
				deleteFolderRecursive(mongoDBPathJournalDir);
				fs.unlinkSync(mongoDBPathLockFile);
			} catch(e){
				pr('Node.js: lock file missing. Continuing anyway');
			}
			pr('Node.js: '+formatDate()+": Spawning MongoDB repair process.");
			var repairChild = spawn(mongoDaemonPath, ['-dbpath',mongoDBPath,'-repair']);
			repairChild.stdout.on('data', function (data) {
			  pr('MonogoDaemon REPAIR: ' + data);
			});
			repairChild.stderr.on('data', function (data) { //not working in ubuntu or just SSH?
			  pr('MonogoDaemon REPAIR: STDERR:**************** ' + data);
			});
			repairChild.on('exit', function (code,signal) { 
				if (code === 0){
					pr('MonogoDaemon REPAIR: '+formatDate()+': ****** Repair attemp was successful. Rerun the app normally ******');
				}else {
					pr('MonogoDaemon REPAIR: '+formatDate()+': ****** Repair attempt failed. Attempt to fix manully. Exit code/signal: '+code+'/'+signal+' ******');
				}				
			});	
	},
	//connects to mongoDB
	init: function () {
		var errorHandler;
		var callback;
		host='localhost'; //default host: '127.0.0.1' 
		port=mongoDB.Connection.DEFAULT_PORT; //default port : 27017
		var serverOptions = {
				'auto_reconnect': true,
				'poolSize': 50, //try bigger pool on load?
				socketOptions: {keepAlive: 1}  //to avoid timeout disconnections
		};
		switch(arguments[0].length){
			case 2:
				if (exports.debugMode) pr("Not spawning daemon");
				spawnDaemonFlag = false;
				host = (arguments[0])[1];
			case 1:
				port = (arguments[0])[0];
			case 0:
				errorHandler = arguments[arguments.length-2];
				callback = arguments[arguments.length-1];
				break;		
		}
		pr('Node.js: '+formatDate()+": Connecting to MongoDB on: "+host+":"+port);
		spawnMongo(port,errorHandler, function(daemonChild){
					if (daemonChild == null && spawnDaemonFlag==true){
						errorHandler(failJSON("couldntSpawn"));
					}else{
						db = new mongoDB.Db('TechnionMap', new mongoDB.Server(host, port, serverOptions),{w:1});
						db.open(function(err, database) {
							if(err) errorHandler(failJSON("couldntConnect",err));
							else {
								db = database;
								usersCol = database.collection("users");
								database.createCollection("promUsers",
										function (err, collection){
											if (err) errorHandler(failJSON("couldntConnect",err));
											promUsersCol = collection;
											collection.update({userId: "ASAT"},{$set:{userId: "ASAT"}},{upsert:true},function (err,result){
													if (err) errorHandler(failJSON("couldntConnect",err));
													else {setTimeout(function(){
																pr('Node.js: '+formatDate()+': Connected to DB on '+host+':'+port );
																callback();														
															},1000);
													}											
											});
										});
							}
						})
					}
		});
	},
	upsertUser: function(data,cb){
		//insert/update user to DB(1), send back OK+friends details for map (2)
		var now = new Date();
		usersCol.update({_id:data.userId}, //1
								{$set:	{
									name: data.name,
									mood: data.mood, 
									thumbnailURL: data.picUrl,
									location: data.location, 
									lastUpdateTime: now.getTime()
									}
								},
								{upsert:true},
				function(err,result){
					if (err) cb(failJSON("couldntUpdate",data.userId,"InsertUser",err),null); //probably no connection/write lock
					else exports.getFriends(data,cb); //2
				});							
	},
	upsertUserFriends: function(data,cb){
		//make sure user in the DB (1),filter FB friends to those in the DB(2),
		//add current user to their friends array(3), insert/update user to DB(4),
		//send back OK+friends details for map (5)
		usersCol.findOne({_id: data.userId },function (err, user){ //1
			if (err) cb(failJSON("couldntSearch",data.userId,"InsertFriends",err),null); //probably no connection
			else if (user){ //execute only if such user exists
					var cursor = usersCol.find({_id: {$in: data.friends} },{ _id : 1 }); //2
					var idArr=[];
					cursor.each(function(err, userFriend) {
							if (err) cb(failJSON("couldntSearch",data.userId,"InsertFriends",err),null); //probably no connection
							else {
								if(userFriend != null) { //true only when cursor exhausted
										if (exports.debugMode) pr("user "+data.userId+": friend found : "+userFriend._id);
										idArr.push(userFriend._id);
										usersCol.update({'_id': userFriend._id},
												{$addToSet: {usersIDarray: data.userId}},
												function (err,doc){} //mandatory callback due to write concern
												);
								}else {
									usersCol.findAndModify({_id:data.userId}, //4 
													[],{$set: {usersIDarray: idArr}},
													{new : true},
											function(err,user){
												if (err) cb(failJSON("couldntUpdate",data.userId,"InsertFriends",err),null); //probably no connection/write lock
												else getFriendsData(user,cb); //5 
											});
								}							
							}
					});
			}else cb(null, okJSON("No User found")); //probably reset occurred
		});		
	},
	getFriends: function(data,cb){
	 //get user's friends array and update last action time (1)
	 //find friends' details and deny those that are too old (2)
	 //find promoted users excluding old posts (3) and retrieve all data found(4)
		usersCol.findOne({_id: data.userId},
				function (err, user){
					if (err) cb(failJSON("couldntUpdate",data.userId,"GetFriends",err),null); //probably no connection/write lock
					if (!user) {	
						cb(null, okJSON("No User found"));  //probably reset occurred
					}else {
						if (user.usersIDarray == null){
							cb(null, okJSON("User hasn't added friends yet"));  //probably reset occurred
						}else getFriendsData(user,cb);
					}
				}				
		);	
	},
	//adding promoted user to collection
	upsertPromoted: function(data,cb){
		var now = new Date();
		promUsersCol.update({"userId" : data.userId},
						{
						userId: data.userId,
						name: data.name,
						mood: data.mood,
						thumbnailURL: data.picURL,
						location: data.location,
						lastUpdateTime: now.getTime()
						},
				function(err,result){
					if (err) cb(failJSON("couldntUpdate",data.userId,"InsertPromoted",err),null); //probably no connection/write lock
					else if (result) cb(null, okJSON("Promoted user saved"));
						 else cb(null,okJSON("Promoted user NOT saved: No such User ID."));
					}
			);							
	},
	//differing users by id and deleting from the proper collection
	deleteUser: function(data,cb){
		var queryIdParsed=Number(data.queryId);
		if (queryIdParsed) {
			usersCol.remove({_id: queryIdParsed},  {"w": 1 ,"single":1},
						function (err,result){
							if (err) cb(failJSON("couldntDelete",data.queryId,"deleteUser",err),null); //probably no connection
							else if (result) cb(null, okJSON("User deleted!"));
								else cb(null, okJSON("User NOT deleted!"));
						});
		}else {
				promUsersCol.remove({userId: data.queryId}, {"w": 1 ,"single":1},
						function (err,result){
							if (err) cb(failJSON("couldntDelete",data.queryId,"deleteUser",err),null); //probably no connection
							else if (result) cb(null, okJSON("Promoted user deleted!"));
								else cb(null,okJSON("Promoted user NOT deleted!"));
						});
		}
	},
	//getting all the users in users collection
	getAllUsers: function(cb){
		usersCol.find({}).sort({lastUpdateTime: -1}).toArray(function(err,users){
					if (err) cb(failJSON("couldntSearch","Admin","GetAllUsers",err),null); //probably no connection
					else if (users) cb(null,okJSON("Users retrieved" , users));
						else cb(null,okJSON("NO users to retrieve" ));
				});							
	},
	//getting all the users in prom(oted)Users collection
	getAllPromUsers: function(cb){
		promUsersCol.find({}).sort({lastUpdateTime: -1}).toArray(function(err,users){
					if (err) cb(failJSON("couldntSearch","Admin","GetAllPromUsers",err),null); //probably no connection
					else if (users) cb(null,okJSON("Promoted users retrieved" ,users)); 
						else cb(null,okJSON("NO promoted users To retrieve" ));
				});							
	},
	//differing users by id and quering from the proper collection
	getUser: function(data,cb){
		var queryIdParsed=Number(data.queryId);
		if (queryIdParsed) {
			usersCol.findOne({"_id": queryIdParsed}, function (err,user){
							if (err) cb(failJSON("couldntSearch",data.queryId,"GetUser",err),null); //probably no connection
							else if (user) cb(null,okJSON("User retrieved!" , user));
								 else cb(null,okJSON("User NOT retrieved!"));
						});
		}else{promUsersCol.findOne({userId: data.queryId}, function (err,user){
							if (err) cb(failJSON("couldntSearch",data.queryId,"GetUser",err),null); //probably no connection
							else if (user) cb(null,okJSON("Promoted user retrieved!" ,user));
								else cb(null,okJSON("Promoted user NOT retrieved!"));
						});
		}		
	},
	//delete TechnionMap db and all its documents
	resetDB: function(cb) {
		db.dropCollection("users",function(err,result){
			if (err) if (err =="MongoError: ns not found"){
					cb(null, okJSON("DB already reset"));
					}else cb(failJSON("couldntReset",err),null);
			else cb(null, okJSON("DB successfully reset"));
		});
	}
};
